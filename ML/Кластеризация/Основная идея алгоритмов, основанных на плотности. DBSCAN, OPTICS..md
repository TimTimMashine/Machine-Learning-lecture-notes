### Основная идея алгоритмов, основанных на плотности:

Алгоритмы, основанные на плотности, такие как **DBSCAN (Density-Based Spatial Clustering of Applications with Noise)**, основываются на идее, что кластеры представляют собой области с высокой плотностью точек, которые отделены областями с низкой плотностью.

![[Pasted image 20250522160333.png]]
![[Pasted image 20250522161054.png]]
1. **Кластеры как области с высокой плотностью**:
    
    - В таких алгоритмах данные рассматриваются как множество точек в пространстве. Кластеры представляют собой области, в которых количество точек на единицу площади (или объема, в зависимости от размерности) достаточно велико.
    - Кластеры определяются не только по расстоянию между точками, но и по количеству точек, которые находятся в пределах некоторого радиуса (или «окружности»).

2. **Шум (Noise)**:
    
    - Важно, что не все точки могут принадлежать кластерам. Некоторые точки могут быть удалены от всех других точек и не образовывать плотные области. Эти точки называются **шумом** (или выбросами).
    - Алгоритмы на основе плотности могут отделять шум от кластеров, что является их ключевым преимуществом перед методами, которые требуют заранее заданного количества кластеров, как в случае с K-средними.
      
3. **Ключевые понятия в алгоритмах плотностных кластеризаций**:
    
    - **Ядро (Core point)**: Точка, которая имеет достаточное количество соседей в пределах радиуса ϵ. Количество соседей зависит от параметра **minPts** (минимальное количество точек).
    - **Сосед (Neighbor point)**: Точка, которая находится в пределах радиуса ϵ от другой точки. Это не обязательно ядро.
    - **Пограничная точка (Border point)**: Точка, которая не является ядром, но находится в пределах ϵ от ядра.
    - **Шум (Noise)**: Точка, которая не является ни ядром, ни пограничной точкой.
    - $\varepsilon$ (эпсилон) - окрестность  
      
4. **Ключевая идея DBSCAN**:
    
    - В алгоритме **DBSCAN** (и аналогичных) каждый кластер начинается с ядра, и все точки, которые можно связать с этим ядром (то есть все точки, которые находятся в пределах ϵ от ядра и имеют достаточное количество соседей), считаются частью этого кластера.
      
    - Алгоритм продолжает расширять кластер, включая новые точки, которые удовлетворяют условиям принадлежности, пока не будут обработаны все точки. Точки, которые не принадлежат никакому кластеру, считаются шумом.
      
5. **Преимущества алгоритмов на основе плотности**:
    
    - **Не требуют заранее заданного числа кластеров**: Алгоритм сам находит количество кластеров, что делает его гибким.
    - **Хорошо справляются с шумом**: Точки, которые не являются частью плотных областей, могут быть отброшены как шум, что позволяет избежать включения выбросов в кластеры.
    - **Гибкость**: Алгоритмы на основе плотности могут находить кластеры произвольной формы, в отличие от алгоритмов, таких как K-средние, которые предполагают круглую или сферическую форму кластеров.
    - ![[Pasted image 20250522161451.png]]
      
6. **Недостатки алгоритмов на основе плотности**:
    
    - **Не всегда легко выбрать параметры**: Алгоритмы, такие как DBSCAN, требуют выбора параметров ϵ (радиус для поиска соседей) и **minPts** (минимальное количество соседей для точки, чтобы она считалась ядром). Эти параметры могут быть чувствительны к данным и требовать настройки для каждой задачи.
      
    - **Неэффективны при очень высоких размерностях**: Алгоритмы плотностной кластеризации могут плохо работать в высокоразмерных пространствах (например, при m ≫ 3m), где концепция плотности теряет смысл из-за «проклятия размерности».

### DBSCAN

**DBSCAN** (Density-Based Spatial Clustering of Applications with Noise) — это один из популярных алгоритмов кластеризации, основанный на плотности. Он не требует заранее задавать количество кластеров и может выявлять кластеры произвольной формы. Алгоритм также способен эффективно выделять шум (выбросы), то есть точки, не принадлежащие ни одному кластеру.

Основная идея DBSCAN — это кластеризация на основе плотности, где кластеры формируются как группы взаимосвязанных точек, которые находятся близко друг к другу, и разделяются регионами с низкой плотностью точек.

##### Основные понятия

1. **Ядро (Core point)**: Точка, у которой есть как минимум minPts точек в пределах радиуса ϵ. Это ключевая точка в формировании кластера.
    
2. **Сосед (Neighbor)**: Точка, которая находится в пределах расстояния ϵ от другой точки. Это может быть как ядро, так и пограничная точка.
    
3. **Пограничная точка (Border point)**: Точка, которая находится в пределах ϵ от ядра, но у неё менее чем minPts соседей в этом радиусе.
    
4. **Шум (Noise)**: Точка, которая не является ядром или пограничной точкой. Она не имеет достаточно соседей и не входит в кластер.
    
##### Шаги алгоритма DBSCAN

1. **Выбор точки**: Алгоритм начинает с произвольной точки и проверяет, является ли она ядром.
    
2. **Проверка плотности**: Для каждой не помеченной точки, проверяется, насколько плотна её окрестность. Если соседей больше или равно minPts, точка становится ядром, и её соседи добавляются в кластер.
    
3. **Расширение кластера**: Если точка является ядром, алгоритм начинает добавлять соседей, которые тоже могут быть ядрами, и продолжает расширять кластер.
    
4. **Повторение для каждой точки**: Алгоритм продолжает этот процесс для каждой точки в наборе данных, пока не будет пройдено все множество точек.

![[Pasted image 20250108224531.png]]

![[Pasted image 20250108224547.png]]

![[Pasted image 20250108224602.png]]

![[Pasted image 20250203113638.png]]

**Пояснение к тому как расширяется кластер**

![[Pasted image 20250203130144.png]]
### OPTICS

##### Параметры и понятия

1. Минимальное кол-во соседей (MinPts), чтобы точка стала ядром
2. Минимальное расстояние $\varepsilon$  чтобы точка считалась соседом

**Основное растояние** - это расстояние от ядра до n - ближайшего соседа, где n - это MinPts. Если точка не ядро, то у неё нет основного расстояния. 

![[Pasted image 20250203141841.png]]

**Достижимое расстояние** - это максимум между основным расстоянием точки и расстоянием между точками. Если основного расстояния не существует, то достижимое расстояние неопределенно. Точка p - всегда должна быть ядром, если существует достижимое расстояние.

![[Pasted image 20250203141551.png]]

##### Алгоритм 

###### 1. Считаем основное расстояние для каждой точки

Порядок вычисления основного расстояния: В алгоритме OPTICS мы начинаем с первой точки и идем по порядку, пока не обработаем все точки. Мы сначала вычисляем для каждой точки её основное расстояние (если оно существует). Алгоритм не пересчитывает основное расстояние для точки больше одного раза, поэтому важно для каждой точки вычислить его один раз.

Как мы считаем основное расстояние: Для каждой точки алгоритм OPTICS будет:

- Находить все точки, находящиеся в радиусе `ε` от текущей точки (ε-окрестность).
- Если количество точек в окрестности больше или равно `MinPts`, то точка считается ядром, и для неё вычисляется основное расстояние.
- Основное расстояние — это расстояние до `MinPts`-й ближайшей точки в этой отсортированной последовательности точек.

![[Pasted image 20250203143452.png]]

###### 2. Считаем достижимое расстояние

Для каждой точки, которая является **ядром** (т.е. у неё есть достаточное количество соседей, чтобы иметь основное расстояние), мы вычисляем **достижимое расстояние** для всех других точек в её **ε-окрестности**.

![[Pasted image 20250203144915.png]]

![[Pasted image 20250203144936.png]]

Хранение

![[Pasted image 20250203145215.png]]

Только лучше хранить в виде словаря, где будет видна точка и её значение (или кортежа)
######  3. Сортируем каждый список по возрастанию 

----------------------

Алгоритм.

Куча — это структура данных, которая упорядочивает элементы, поддерживая свойство **min-heap** (минимальная куча). В минимальной куче каждый родительский элемент меньше или равен своим дочерним элементам. Таким образом, минимальный элемент всегда находится в корне (в начале списка).

1. Инициализируем массивы
2. for i по каждой точки
3. Если точка не посещена 
4. Считаем всех её соседей 
5. Считаем её основное расстояние
6. Если оно существует (точка яв. ядром)
7. Создаем список очередь
8. Обновляем список очередь

9. 8.1 -  Считаем основное расстояние снова для точки
10. 8. 2 цикл проходиться по всем соседям
11. 8. 3 если они не посещены, считаем достижимое расстояние к ним.
12. 8. 4 записываем его в массив, если оно не существовал, если существовало сравниваем с предыдущим
13. 8.5 добавляем элемент в кучу (в итоге получается куча - где каждый элемент это кортеж с индексом и значения достижимого расстояния до текущей точки)

14. пока очередь не пустая извлекаем минимальный элемент из кучи
15. если индекс значения не был посещен
16. считаем новых соседй для индекс минимального значения
17. обновляем список посещений
18. если существует для текущего индекса минимального значения основное расстояние
19. снова обновляем список с очередью все начиается опять с пункта 8.1 и далее по кругу пока все элементы не будут посещенны то есть обработаны




```import numpy as np  
import heapq  
  
def dist(v, q):  
    return np.linalg.norm(v - q)  
  
def neighbors(v, db, eps):  
    return [i for i, q in enumerate(db) if dist(v, q) <= eps]  
  
def core_dist(v, db, eps, min_pts):  
    neigh = neighbors(v, db, eps)  
    if len(neigh) >= min_pts:  
        return sorted([dist(v, db[i]) for i in neigh])[min_pts - 1]  
    return None  
  
def update1(neigh, p, queue, db, eps, min_pts, core_from, visited, reach_dist):  
    coredist = core_dist(db[p], db, eps, min_pts)  
    for o in neigh:  
        if not visited[o]:  
            new_dist = max(coredist, dist(db[p], db[o]))  
            if reach_dist[o] is None:  
                reach_dist[o] = new_dist  
                core_from[o] = p  
                heapq.heappush(queue, (new_dist, o))  
            else:  
                if new_dist < reach_dist[o]:  
                    reach_dist[o] = new_dist  
                    core_from[o] = p  
                    heapq.heappush(queue, (new_dist, o))  
  
def optics(db, eps, min_pts):  
    n = db.shape[0]  
    visited = [False] * n  
    reach_dist = [None] * n  
    core_from = [-1] * n  
    order = []  
  
    for p in range(n):  
        if not visited[p]:  
            neigh = neighbors(db[p], db, eps)  
            visited[p] = True  
            order.append(p)  
  
            if core_dist(db[p], db, eps, min_pts) is not None:  
                queue = []  
                update1(neigh, p, queue, db, eps, min_pts, core_from, visited, reach_dist)  
                while queue:  
                    _, s = heapq.heappop(queue)  
                    if not visited[s]:  
                        neigh_q = neighbors(db[s], db, eps)  
                        visited[s] = True  
                        order.append(s)  
                        if core_dist(db[s], db, eps, min_pts) is not None:  
                            update1(neigh_q, s, queue, db, eps, min_pts, core_from, visited, reach_dist)  
  
    dist_res = []  
    index_res = []  
    for idx in order:  
        if reach_dist[idx] is None:  
            dist_res.append(-1)  
            index_res.append(-1)  
        else:  
            dist_res.append(reach_dist[idx])  
            index_res.append(core_from[idx])  
  
    return dist_res, index_res  
  
with open('input.txt', 'r') as f1:  
    n, m, eps, minPts = map(float, f1.readline().strip().split())  
    n, m, minPts = int(n), int(m), int(minPts)  
  
    data = np.zeros((n, m))  
    for i in range(n):  
        data[i] = np.array(f1.readline().strip().split(), dtype=float)  
  
    reach_dist, core_from = optics(data, eps, minPts)  
  
with open('output.txt', 'w') as f2:  
    f2.write(" ".join(f"{j:.3f}" if j is not None else "-1.000" for j in reach_dist) + "\n")  
    f2.write(" ".join(map(str, core_from)) + "\n")
```

Прочитать про кучи и очереди 


#### Алгоритм OPTICS (по твоему описанию):

1. **Инициализация массивов**:
    
    - Массивы для хранения результатов: `reachability_distance` (достижимое расстояние), `core_point_from` (индекс исходной точки для достижения текущей точки), `processed` (флаг посещения точек), и очередь для обработки точек.
2. **Цикл по каждой точке**:
    
    - Для каждой точки (индекса `i`) в базе данных выполняется основной цикл.
3. **Если точка не посещена**:
    
    - Проверяем, была ли точка уже посещена. Если нет, продолжаем с ней работать.
4. **Считаем всех её соседей**:
    
    - Для текущей точки вычисляем все точки, которые находятся на расстоянии, не превышающем `ε` (эпсилон), т.е. находим соседей этой точки.
5. **Считаем её основное расстояние (core distance)**:
    
    - Рассчитываем основное расстояние для точки, которое определяется как расстояние до `min_pts`-го ближайшего соседа (если точка имеет достаточно соседей).
6. **Если точка является ядром (имеет достаточное количество соседей)**:
    
    - Если основное расстояние существует (то есть точка является ядром), начинаем обработку её соседей.
7. **Создаем очередь (сортированная очередь)**:
    
    - Создаем очередь для точек, которые будут обрабатываться. Очередь отсортирована по достижимому расстоянию.
8. **Обновляем список очереди** (для текущей точки):
    
    - Для каждого соседа, который еще не посещен, вычисляем достижимое расстояние и добавляем в очередь. Если соседа еще не было в очереди, добавляем его. Если он уже есть, то обновляем его достижимое расстояние, если новое значение меньше текущего.
9. **Повторение 8 для всех соседей**:
    
    - Для каждого соседа (из списка соседей) выполняем шаги с 8.1 по 8.5:
        
    - **8.1. Считаем основное расстояние снова для точки** — снова вычисляем core distance для соседа.
        
    - **8.2. Цикл проходит по всем соседям** — каждый сосед проверяется для дальнейшей обработки.
        
    - **8.3. Если сосед не посещен, считаем достижимое расстояние к нему** — вычисляем расстояние до соседа и, если оно меньше, чем текущее достижимое расстояние, обновляем его.
        
    - **8.4. Записываем достижимое расстояние** в массив (если оно еще не было записано) или обновляем его, если новое значение меньше.
        
    - **8.5. Добавляем элемент в очередь** — помещаем точку в очередь с её достижимым расстоянием, чтобы её можно было обработать позже.
        
10. **Пока очередь не пустая, извлекаем минимальный элемент**:
    
    - Извлекаем точку с минимальным достижимым расстоянием из очереди и начинаем её обработку.
11. **Если точка не была посещена**:
    
    - Проверяем, была ли точка посещена. Если нет, продолжаем обработку.
12. **Считаем новых соседей для текущей точки**:
    
    - Для извлеченной точки находим её соседей.
13. **Обновляем список посещений**:
    
    - Помечаем точку как посещенную.
14. **Если для текущей точки существует основное расстояние**:
    
    - Если точка является ядром (имеет основное расстояние), продолжаем обработку её соседей и повторяем шаги с 8.1.
15. **Повторяем процесс** до тех пор, пока все точки не будут посещены.
    
16. Алгоритм завершен, когда все точки были обработаны и все очереди очищены.
    

#### Объяснение каждого этапа:

- **Шаги 1-6** — это основная подготовка и вычисление того, является ли точка ядром. Это важный момент, потому что точки, не являющиеся ядром, не будут иметь соседей, которые могут быть достигнуты с минимальными расстояниями.
    
- **Шаги 7-9** — когда точка является ядром, мы начинаем взаимодействовать с её соседями, обновляем их достижимые расстояния и добавляем в очередь для дальнейшей обработки.
    
- **Шаги 10-15** — обрабатываем очередь, извлекая минимальные элементы (с минимальным достижимым расстоянием), и повторяем обработку их соседей, пока все точки не будут посещены.
    

#### Важные моменты:

- В алгоритме важно поддерживать свойство мин-кучи для очереди (чтобы всегда извлекать точку с минимальным достижимым расстоянием). Это помогает эффективно обрабатывать точки, начиная с тех, которые легче достигнуты.
- Этапы 8-15 обрабатывают каждый индекс на основе его достижимого расстояния и соседей, эффективно строя кластеризацию.

Если алгоритм оптимизирован и реализован верно, он позволяет эффективно выделять кластеры и определять связи между точками в пространстве.